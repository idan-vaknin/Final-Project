\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{amsfonts}
%\usepackage{stmaryrd}


\title{\textbf{Practical Fully Secure Three-Party Computation via Sub-linear Distributed Zero-Knowledge Proofs} \break Supervisor:\break Niv Gilboa}
\author{  Vitali Lopushenko\\
	\texttt{317104347}
	\and
	Osher saragani\\
	\texttt{315348706}\
	\date{30.12.2019}
	

	}

\begin{document}


\begin{figure}
	\centering
	\includegraphics[width=0.6\linewidth]{a.png}
\end{figure}

\maketitle
\begin{figure}
	\centering
	\includegraphics[width=0.3\linewidth]{cse_logo.png}
\end{figure}

\pagebreak
\tableofcontents

\pagebreak

\listoffigures
\pagebreak

\section{Introduction}

\subsection{Abstract}
Secure Multi-Party Computation (MPC) is a subfield in information security, the goal of the group is to calculate a certain function by collecting one input from each party while keeping their input private. The protocol which we are going to implement does not require a server or an access point and is fully distributed. Furthermore, the protocol minimizes the communication overhead by aspiring to do most of the computations locally with reasonable computation complexity.
The protocol maintains fairness and security in a sense that a semi-honest party or malicious adversary, cannot manipulate the function output nor learn the output of the other parties as long as there is an honest majority.


\subsection{Motivation}
Traditional MPC is an asynchronous model, consider a simple setting with $n$ parties that desire computes a function with their input without revealing it. The $n$ parties send their inputs to some trusted party $p$ and wait for an answer from $p$, the party $p$ receives all inputs, calculates function $f$ and sends the output to all parties. An Asynchronous MPC model achieves the same result without trusted party $p$ by using the secret-sharing protocol to share the secret inputs and calculate distributedly the function $f$, for further reading \cite{sync_async}. 
2PC formally introduced in the early 80’s in the millionaire’s problem where two millionaires wish to find out which one of them has more money but neither of them wanted to reveal their exact amount of cash each of them possesses. Furthermore, both of them agreed that the involvement of a third party was not desirable. Later the need for a general solution has risen, s.t. $n$ parties wish to calculate some function $f$.  Formally,The setting of secure multi-party computation consists of $n$ parties with their private inputs $[x_1, \ldots ,x_n]$ (where $x_i$ is the private input of party $i$) that wish to jointly compute the functions $f_i(x_1, \ldots ,x_n)$, where player $i$ receives the output  $f_i(x_1, \ldots ,x_n)$. If there were a trusted party, then all parties could have sent their inputs to it, and the trusted party could have privately sent each  $f_i(x_1, \ldots ,x_n)$ to player $i$. In this setting it is clear that player $i$ learns nothing but its designated output. its very efficient with two parties, however, as the number of parties increases the communication overhead increases as well. Additionally, the communication cost greatly relies on channel performance and can expose the party to side-channel-attacks. 3PC topology has been growing in popularity in the last few years and  simple enough to analyze.Moreover, it is the minimal size which is needed for an honest majority.

\subsection{secure computation}
We will focus on protocols that provide security against semi-honest parties controlled by an adversary. this type of adversary is assumed to follow the instructions that are prescribed for him by the protocol. However, he may try to learn additional information from the messages that his parties receive, In our case, the secret inputs of each party. A stronger type of corruption is performed by adversary who is malicious. That adversary can operate in any way he chooses and usually will not obey the protocol.

\subsection{Our contribution}
In this paper, we present an MPC protocol which minimizes the communication cost in expense of reasonable amount of local computations. The protocol is exactly the protocol described in \cite{main}. We are going to  present a full implementation of the protocol with a verification phase included, in which each party make sure that every member was honest throughout the execution of the protocol.
Moreover, we wish to run different ways of implementation, analyze our results and achieve a better understanding of using the protocol in practice. We hope that our work will be used in the future and help provide practical results which push the work already done ahead.  

\pagebreak

\section{The project and preliminaries}
Our project is implementing the whole system described in the article by Niv Gilboa, Elette Boyle, Yuval Ishai and Ariel Nof in paper Practical Fully Secure Three-Party Computation \cite{main}.\hfill\break
In our setting of Three parties, $p = (p_1,p_2,p_3)$, connected by TCP connection. We assume an honest majority, in our settings e.g. one malicious party. The function $f$ to be computed by the parties is a public circuit $C$ that composed of addition and multiplication gates over F a finite field over the ring $\mathbb{Z}_{2^k}$ - the ring of integers modulo $2^k$.  $[n]$ is the set $[0 \ldots n]$, $[[u]]$ is the part of $u$  that party $i$ holds $[[u]] = (u_i, u_{(i-1)}).$
\hfill\break
\hfill\break
\hfill\break

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{"../../Desktop/Google Drive/Project/Figures/fig1"}
	\caption{The Model}
	\label{fig:fig1}
\end{figure}


\subsection{definitions and concepts}
\textbf{MPC}- Multi-Party Communication.\hfill\break
\textbf{Semi-honest MPC}: A malicious party that tries to learn as much as he can about the protocol, even things he does not suppose to know in order to participate in the protocol. However, the party follows the protocol and function as you would expect from an honest party.\hfill\break
\textbf{Malicious secure MPC}: As long as there is an honest majority, the protocol guarantees that no malicious party can manipulate the system into false output. \hfill\break 
\textbf{Replicated secret sharing}: In generally replicated secret sharing isn’t efficient, however, in a small number of participants, it seems to perform very well. the replicated secret sharing scheme used in our protocol is optimized for 3 parties. \hfill\break
To share a secret $v$ over the ring $\mathbb{R}$, The dealer needs three random values it’s done by choosing two random values $v_1, v_2$ and compute by $v_3 = v - v_1 - v_2$. then the dealer construct shares for each party so that $p_1$s share is $(v_1,v_3)$, $p_2$ shares is $(v_2,v_1)$ and $v_3$ shares $(v_3,v_2)$ in genarally $p_i$ share is $(v_i,v_{i-1})$.


\subsection{Parts of the project}

\subsubsection{secret sharing}
As mentioned above, there is no need for a trusted third party which receives all the inputs, calculates the function and sends out the result to all parties, the computation is distributed between 3 parties that work synchronously in parallel with a reasonable amount of communication as described in \cite{main_based}.
The first step is to share the secret input of each party with other parties. $\mathcal{F}_{rand}$ - This functionality allows the generation of a random value(a member of the ring) and divide this value into shares, one for each party in the following manner. Firstly, Each party $i$ generates a random key $k_i$ send it to $p_{i+1}$ and calculate $\mathcal{F}_{k_i}(id)$ to be its random element Alpha $i$. $\mathcal{F}_{k_i}()$ is a deterministic function which takes a counter that was agreed upon earlier. That way the random element $\alpha$ is divided into shares: $\alpha_1$,  $\alpha_2$, $\alpha_3$. Party $p_i$ holds $\alpha_i$ and $\alpha_(i-1)$. \hfill\break
$\mathcal{F}_{input}$ - this functionality uses $\mathcal{F}_{rand}$ to generate a random value and divide it into shares as explained above. Then each party computes its secret input $X_i$ minus $\alpha$ and broadcast it to all other parties. That way each party holds $[[X_i - \alpha]]$ shares. Each party has its shares of Alpha e.g  $[[\alpha]]$ so he can compute his share of $X_i$ by: $[[X_i - \alpha]] + [[\alpha]] = [[X_i]]$.\hfill\break
After each party receives its shares and rebuilt it to Three shares: $(v_1,v_3),\hfill\break (v_2,v_1), (v_3,v_2)$. Each party holds a different set of shares. That way, no party could learn about the output of the other parties and vice versa. this functionality fully described in \cite{f_input}.


\subsubsection{The Calculation of C circuit}
Every function can be broken down into its Boolean components. That is a Boolean function that uses XOR ($\bigoplus$) gates for addition and AND ($\cdot$) gate for multiplication.\hfill\break
In each round, either an addition gate or a multiplication gate is calculated by each party with its shares of the inputs. For example, in order to compute $u+v$ each party $p_i$ sets its share to be $(u_i+v_i, u_{i-1}+v_{i-1})$ where the share of $[[u]] = (u_i, u_{i-1})$ and the share of $[[v]] = (v_i, v_{i-1})$.
For the addition gates, there is no communication required whatsoever. However, for the multiplication gate, there is some communication required. After all the members finish to calculate the desired function, another phase is needed in the semi-honest model. That step is called the verification phase and is conducted distributedly as well. This extra step’s goal is to make sure that every party did not lie on one or more of the communication steps that were carried out during the multiplication gates.In a case where everyone was honest every party output the function result as a success. In a case where the last phase discovered conflict, that is someone lied, every party outputs an abort signal.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\linewidth]{"../../Desktop/Google Drive/Project/Figures/ArithmiticCircuit"}
	\caption{Function and its Boolean components}
	\label{fig:arithmiticcircuit}
\end{figure}
\pagebreak
\subsubsection{Verification}
Verifying Correctness of Messages, the goal of this function is to verify that all messages that were sent by the parties during the execution are correct according to the protocol. this function extended the protocol mentioned in \cite{main_based}.\hfill\break For each multiplication gate party $p_i$ sends one message $z_i$ to $p_{i+1}$.
\begin{equation} \label{eq:1}
z_i = u_i*v_i + u_i*v_{i-1} + u_{i-1}*v_i + \alpha_i
\end{equation}
Let $c$ 
\begin{equation} \label{eq:2}
c(u_i, u_{i-1}, v_i, v_{i-1}, \alpha_i, z_i) = u_i*v_i + u_i*v_{i-1} + u_{i-1}*v_i + \alpha_i - z_i
\end{equation}
we need to ensure that $c = 0$ on every communication stage of the function 
$\mathcal{F}_{vrfy}$ receives from each party $p_j$ its inputs $(u_k, u_{k-1},v_k,v_{k-1},\alpha_k,z_k)$ for each $k$ in $m$.
For each stage, the input to $c$ is distributed among $p_{i+1}$ and $p_{i-1}$.  specifically, $u_i,v_i,\alpha_i$ and $z_i$ are known to $p{i+1}$ and $u_{i-1},v_{i-1}, \alpha_{i-1} $ known to $p_{i-1}$. value of $\alpha_{i-1}$ can be calculated since $\alpha_i = -\alpha_{i-1} - \alpha_{i+1}$ 


\subsection{Prior knowledge}
Knowledge needed for implementing the project, information security, C++ programming, STL library, principles in program design, work with git as a source control platform. basic knowledge in Boolean algebra, learn about possible security breaches so we can avoid them and write an implementation as secure as possible. 

\subsection{Tools and Programs we used}
\textbf{Visual Studio IDE:} We choose to implement the code in C++, visual studio is a popular IDE for programming.
\hfill\break
\textbf{Draw.io:} Its a platform for creation of block diagram.
\hfill\break
\textbf{TeXstudio:} - LaTeX development environment, LaTeX is a document preparation platform use for academic and mathematic articles writing.
\hfill\break
\textbf{Git:} Is a distributed version-control system for tracking changes in source code during software development.
\hfill\break
\textbf{Exell:} For the gant design and time line. 

\pagebreak

\subsection{Flow diagram}
The first step in the process is sending the circuit which all of the parties are computing distributedly and may be some other preparation. Then, the parties divide and send their inputs’ shares using $\mathcal{F}_{input}$. At the end of this step each party hold 2 shares of each input. In case the input sharing is not successful the protocol aborts. Otherwise, we move to the step of calculating the desired circuit.after calculating the function we move forward into the verification step where each party makes sure that the other parties were honest. In case the answer to this question is no then the protocol aborts or perform reconstruct to get the final output otherwise.
\hfill\break
\hfill\break

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{"../../Desktop/Google Drive/Project/Figures/High-level flow chart"}
	\caption{Flow diagram}
	\label{fig:high-level-flow-chart}
\end{figure}


\pagebreak
\section{Timeline}
\subsection{Milestones}
We present our timeline and progress in tables on this section.\hfill\break
we set a clear goals for the project for improved further planning and punctuality.
\hfill\break
\hfill\break

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.7]{"../../Desktop/Google Drive/Project/Figures/gant_fig_1"}
	\caption{Milestones}
	\label{fig:gantfig1}
\end{figure}

As seen in figure \ref{fig:gantfig1} we changed subject of the project, our first research was on extention OT protocol and homomorphic secret sharing.
\pagebreak

\subsection{Gant}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{"../../Desktop/Google Drive/Project/Figures/gant_fig"}
	\caption{Gant}
	\label{fig:gantfig1}
\end{figure}



\pagebreak
\section{Bibliography}
\begin{thebibliography}{9}
	
	\bibitem{main}
	Dan Boneh and Elette Boyle and Henry Corrigan-Gibbs and Niv Gilboa and Yuval Ishai
	\textit{ "Practical Fully Secure Three-Party Computation via Sublinear Distributed Zero-Knowledge Proofs."}
	In Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, pp. 869-886. ACM, 2019.
	
	\bibitem{main_based}
	Boyle, Elette, Niv Gilboa, Yuval Ishai, and Ariel Nof
	\textit{ "Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs."}
	Cryptology ePrint Archive, Report 2019/188.

	\bibitem{f_input}
	Koji Chida and Daniel Genkin and Koki Hamada and Dai Ikarashi and Ryo Kikuchi and Yehuda Lindell and Ariel Nof
	\textit{ "Fast Large-Scale Honest-Majority MPC for Malicious Adversaries"}
	Cryptology ePrint Archive, Report 2018/570.
	
	\bibitem{sync_async}
	Dani, Varsha, Valerie King, Mahnush Movahedi, Jared Saia, and Mahdi Zamani
	\textit{ "Secure multi-party computation in large networks"}
	Distributed Computing 30, no. 3 (2017): 193-229.
	
	\bibitem{OT}
	Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai and Lisa Kohl and Peter Rindal and Peter Scholl
	\textit{ "Efficient Two-Round OT Extension and Silent Non-Interactive Secure Computation"}
	Cryptology ePrint Archive, Report 2019/1159
	
	\bibitem{homomrphic_secret_sharing}
	Elette Boyle and Geoffroy Couteau and Niv Gilboa and Yuval Ishai and Michele Orrù
	\textit{ "Homomorphic Secret Sharing: Optimizations and Applicationsks"}
	Cryptology ePrint Archive, Report 2018/419.
	
	\bibitem{replicated_secret_sharing}
	Furukawa, Jun and Lindell, Yehuda
	\textit{ "Two-Thirds Honest-Majority MPC for Malicious Adversaries at Almost the Cost of Semi-Honest"}
	Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security.
	
	\bibitem{temp0}
	Eerikson, Hendrik, Claudio Orlandi, Pille Pullonen, Joonas Puura and Mark Simkin.
	\textit{ "Use your Brain! Arithmetic 3PC For Any Modulus with Active Security"}
IACR Cryptology ePrint Archive 2019 (2019): 164.

	\bibitem{temp1}
Furukawa, Jun and Lindell, Yehuda and Nof, Ariel and Weinstein, Or.
\textit{ "High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority"}
Advances in Cryptology – EUROCRYPT 2017.


\end{thebibliography}
\pagebreak


\end{document}
